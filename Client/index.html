<!DOCTYPE html>
<head>
    <link href="css/styles.css" rel="stylesheet"/>
    <script src="Javascript/Complex.js"></script>
    <script src="Javascript/Fourier.js"></script>
    <script src="Javascript/Phillips.js"></script>
    <script src="Javascript/buffer.js"></script>
    <script src="Javascript/chunck.js"></script>
    <script src="Javascript/camera.js"></script>
    <script src="Javascript/ocean.js"></script>
    <script src="Javascript/texture.js"></script>
    <script src="Javascript/skybox.js"></script>
    <script src="Javascript/plot.js"></script>
    <script src="Javascript/scene.js"></script>
    <script src="Javascript/FrameBuffer.js"></script>
    <script src="gl-matrix.js"></script>

<script id="skyBoxVertexShader" type="x-shader/x-vertex">
        precision mediump float; 
        uniform mat4 projMatrix; 
        uniform mat4 viewMatrix; 

        attribute vec2 texCoord; 
        attribute vec3 position; 

        varying vec2 texcoord; 
        varying vec3 wPos; 
        varying vec4 eyespacePos;

        varying float size;
        
        void main(void) 
        { 
            texcoord = texCoord;    
            wPos = position; 
	    size = 2000.0;

            eyespacePos =   vec4(position.x * size, position.y * size  ,position.z * size , 1.0) ;
            
            gl_Position = projMatrix * viewMatrix * vec4(position.x* size, position.y * size ,position.z * size, 1.0);
            
        }

    </script>
<script id="skyBoxfragmentShader" type="x-shader/x-fragment">
        precision highp float;

        varying vec2 texcoord; 
        varying vec3 wPos; 
        varying vec4 eyespacePos;
	varying float size;

        uniform sampler2D texture; 
        uniform vec3 cameraPosition;
        
        uniform vec4 clipplane;
        uniform float isclipped;

	const float Pi = 3.1415;
	

        vec3 mie(float dist, vec3 lightColor){ 
            return max(exp(-pow(dist, 0.45)) * lightColor - 0.1, 0.0); 
        } 
        
        float distance(vec3 vector) 
        {
            return sqrt(vector.x*vector.x + vector.y*vector.y + vector.z*vector.z); 
        } 
        
        void main(void) 
        { 
	  vec4 LIGHT_POSITION = vec4(2000.0,3.0,-2000.0, 1.0);
	  
	  float lightDistance = distance(LIGHT_POSITION.xyz);
	
	  float clampedDistance= clamp(lightDistance, 0.0, 1.0);
          float sun = clamp(1.0 - smoothstep(0.01, 0.1, clampedDistance), 0.0, 1.0);
	
	  float h = wPos .y + 0.01;
	        h = (0.5 * mix(clampedDistance, 1.0, h)) / h;
    
          vec3 gradient= mie(lightDistance, vec3(0.5));
		
	  vec3 color = h * vec3(0.32, 0.6, 1.0);
    
    	  color = max(color, 0.0);
    
	  color = max(mix(pow(color, 1.0 - color), color / (2.0 * color + 0.5 - color), clamp(LIGHT_POSITION.y* 2.0, 0.0, 1.0)),0.0) + sun + gradient;

            if(isclipped == 1.0 && dot(eyespacePos, clipplane) >= 0.0)
            { 
                discard; 
            } 
            
	  		
          if(wPos.y < -0.01)
                gl_FragColor = vec4(0.15,0.2,0.24, 1.0);        
          else
                gl_FragColor = vec4(color, 1.0);
            
	  
           float phi = 2.0*Pi;
	   
           
           for(float i=0.0; i < 3.1415*2.0;i+=0.05)
	    {
		float x = cos(i)*0.025;
		float y = sin(i)*0.025;
	
		if(wPos.y -0.2 < y && wPos.x - 0.62 < x && wPos.x -0.62 > -x && wPos.y -0.2 > -y)
		    gl_FragColor = vec4(1.0, 1.0, 0.95, 1.0);
	    }

	}
    </script>
16:48 28.07.2017
<script id="vertexShader" type="x-shader/x-vertex">
        precision mediump float; 
        precision highp sampler2D;

        uniform mat4 projMatrix; 
        uniform mat4 viewMatrix;
        uniform mat4 birdviewMatrix;

        uniform vec3 cameraPosition; 

        uniform mat4 invProjMatrix;
        uniform mat4 invViewMatrix;
          
        uniform sampler2D displacement; 

        attribute vec3 position; 
        attribute vec2 texCoord; 
        
        varying vec2 texcoord; 
        varying vec4 clipSpace;
        
        varying vec4 wPosition; 
        varying vec4 pos; 
        varying vec3 camPos;
        
        
        void main(void)
        { 
            vec4 vertex = vec4(position.x, position.z, 0.0, 1.0); 
    
            vec3 cameraSpace = normalize((invProjMatrix * vertex).xyz);
            vec3 worldSpace  = (invViewMatrix * vec4(cameraSpace, 0.0)).xyz;

            float t = (-cameraPosition.y)/worldSpace.y ;

            vec3 u =  (cameraPosition + t * worldSpace);
	    
            

            texcoord = (u.xz + 1.0) * 0.5; 
    
	    vec4 d = texture2D(displacement, texcoord);
            
            camPos = cameraPosition;
              
            //attenuation horizont
            float att = 1.4/pow(length(camPos - u), 1.0/3.0);
            
            u.y = d.y * att;
            u.x = (u.x + d.x);
            u.z = (u.z + d.z);
    		
            wPosition = vec4(u.x, u.y, u.z, 1.0);
                    
            clipSpace  = projMatrix * viewMatrix * vec4(u , 1.0); 
            
           
            pos = (viewMatrix * vec4(worldSpace , 1.0)); 
            
            if (t > 0.0) 
            {
                gl_Position = projMatrix * viewMatrix * vec4(u , 1.0);
            }
            else
            {
                gl_Position = vec4(0.0,0.0,0.0,0.0);
             }
            
                
         }
    </script>
<script id="fragmentShader" type="x-shader/x-fragment">

        precision highp float;
        precision highp sampler2D;

        varying vec2 texcoord; 

        uniform sampler2D displacement; 
        uniform sampler2D reflectionSampler;
        uniform sampler2D refractionSampler; 
        
        varying vec3 camPos;
        varying vec4 wPosition;
        varying vec4 normalWorld; 
        varying vec4 pos; 
        
        varying vec4 eyespacePos;
        varying vec4 clipSpace;
       

        vec3 calcNormals(sampler2D text, vec2 texcoords) { 

            float texel = 1.0 / 128.0;
            float texelSize =   2.0/ 128.0; 

            vec3 center = texture2D(text, texcoords).xyz; 

            vec3 left   = vec3(-texelSize, 0.0,0.0)  + texture2D(text, texcoords + vec2(-texel, 0.0)).xyz - center; 
            vec3 right  = vec3(texelSize, 0.0, 0.0)  + texture2D(text, texcoords + vec2(texel, 0.0)).xyz  - center; 
            vec3 bottom = vec3(0.0, 0.0, texelSize)  + texture2D(text, texcoords + vec2(0.0, texel)).xyz  - center;
            vec3 top    = vec3(0.0, 0.0, -texelSize) + texture2D(text, texcoords + vec2(0.0, -texel)).xyz - center; 

            vec3 topRight    = cross(right, top); 
            vec3 topLeft     = cross(top, left); 
            vec3 bottomLeft  = cross(left, bottom); 
            vec3 bottomRight = cross(bottom, right); 
    
            return normalize(bottomRight+bottomLeft+topLeft+topRight); 
        } 

        vec3 calcTang(sampler2D text, vec2 texcoords)
        {
             float texel = 1.0 / 128.0;
             float texelSize =   2.0/ 128.0; 

             vec3 center = texture2D(text, texcoords).xyz; 

             return vec3(-texelSize, 0.0, 0.0)  + texture2D(text, texcoords + vec2(-texel, 0.0)).xyz  - center; 
        }

        
        
        void main(void) { 
            vec3 LIGHTCOLOR         = vec3(0.5, 0.5, 0.5); 
            vec3 SEA_WATER_COLOR    = vec3(0.05,0.1,0.15); 
            vec3 DEEP_SEA_COLOR     = vec3(0.04,0.15,0.2);
            vec4 LIGHT_POSITION     = vec4(1000.0,3.0,-1900.0, 1.0); 

            vec3 lightDir = normalize(LIGHT_POSITION.xyz); 
            vec3 view     = normalize(camPos - wPosition.xyz); 

            vec3 H = (lightDir + view)/length(lightDir + view);
                
            vec2 reflectionCoord;
            vec2 refractionCoord;
             
            reflectionCoord.x = 0.5*(clipSpace.w + clipSpace.x)/clipSpace.w;
            reflectionCoord.y = 0.5*(clipSpace.w + clipSpace.y)/clipSpace.w;
    
            refractionCoord.x = 0.5*(clipSpace.w + clipSpace.x)/clipSpace.w;
            refractionCoord.y = 0.5*(clipSpace.w + clipSpace.y)/clipSpace.w;
    
            vec3 normal  = calcNormals(displacement, texcoord);
           
            if (dot(view, normal) < 0.0) {
                normal = reflect(normal, view);
            }  
            
        
            vec4 reflectionTex = texture2D(reflectionSampler, reflectionCoord +normal.xz*0.1); 
        
            float diffuseFactor = clamp(dot(normal, lightDir.xyz), 0.0, 1.0); 
            
            float fresnel = 0.02 + 0.98 * pow(1.0 - dot(normal, view), 5.0);

            vec3 refraction = SEA_WATER_COLOR+reflectionTex.xyz * diffuseFactor*0.1; 
            vec3 reflection = reflectionTex.xyz;
		
            vec3 color = refraction*(1.0 -fresnel) + fresnel * reflectionTex.xyz;
            color += DEEP_SEA_COLOR* (wPosition.y*2.0/(length(camPos.xyz - wPosition.xyz)));
		
            float specular = pow(max(0.0, dot(reflect(lightDir, normal),-view)),1000.0) * 10.0; 
            
            if(diffuseFactor>0.0)
                color+= specular * LIGHTCOLOR;
     
            gl_FragColor = vec4(color, 1.0); 
    }
     </script>
</head>

<body>
    <div id="panel">
        <img id="spectrum"      width="128" height="128"/>
        <img id="hu"            width="128" height="128"/>
        <img id="spacial"       width="128" height="128"/>
        <input type = "text"    width="20" id="camera-height"/>
        <label id="cheight-lbl">camera height</label>
        <label id="choppiness-lbl">choppiness</label>
        <input id="choppiness" type="range" min="0" max="10" value="9" />
    </div>
    <canvas id="canvas"></canvas>
</body></html>
