<!DOCTYPE html>
<head>
    <link href="css/styles.css" rel="stylesheet"/>
    <script src="Javascript/Complex.js"></script>
    <script src="Javascript/Fourier.js"></script>
    <script src="Javascript/Phillips.js"></script>
    <script src="Javascript/buffer.js"></script>
    <script src="Javascript/chunck.js"></script>
    <script src="Javascript/camera.js"></script>
    <script src="Javascript/ocean.js"></script>
    <script src="Javascript/texture.js"></script>
    <script src="Javascript/skybox.js"></script>
    <script src="Javascript/plot.js"></script>
    <script src="Javascript/scene.js"></script>
    <script src="Javascript/FrameBuffer.js"></script>
    <script src="gl-matrix.js"></script>

<script id="skyBoxVertexShader" type="x-shader/x-vertex">
        precision mediump float; 
        uniform mat4 projMatrix; 
        uniform mat4 viewMatrix; 

        attribute vec2 texCoord; 
        attribute vec3 position; 

        varying vec2 texcoord; 
        varying vec3 wPos; 
        varying vec4 eyespacePos;

        float size = 2000.0;
        
        void main(void) 
        { 
            texcoord = texCoord; 
            wPos = position; 

            eyespacePos = vec4(position.x*size, position.y*size  ,position.z*size , 1.0) ;
            
            gl_Position = projMatrix * viewMatrix * vec4(position.x* size, position.y * size ,position.z * size, 1.0); 
        }

    </script>
<script id="skyBoxfragmentShader" type="x-shader/x-fragment">
        precision highp float;

        varying vec2 texcoord; 
        varying vec3 wPos; 
        varying vec4 eyespacePos;

        uniform sampler2D texture; 
        uniform vec3 cameraPosition;
        
        uniform vec4 clipplane;
        uniform float isclipped;

        vec3 mie(float dist, vec3 lightColor){ 
            return max(exp(-pow(dist, 0.45)) * lightColor - 0.1, 0.0); 
        } 
        
        float distance(vec3 vector) 
        {
            return sqrt(vector.x*vector.x + vector.y*vector.y + vector.z*vector.z); 
        } 
        
        void main(void) 
        { 
		vec4 LIGHT_POSITION = vec4(1000.0,3.0,-1900.0, 1.0); 

		float lightDistance = distance(LIGHT_POSITION.xyz);
	
		float clampedDistance= clamp(lightDistance, 0.0, 1.0);
		float sun = clamp(1.0 - smoothstep(0.01, 0.1, clampedDistance), 0.0, 1.0);
	
		float h = wPos .y + 0.01;
		h = (0.5 * mix(clampedDistance, 1.0, h)) / h;
    
    		vec3 gradient= mie(lightDistance, vec3(0.5));
		
		vec3 color = h * vec3(0.32, 0.6, 1.0);
    
    		color = max(color, 0.0);
    
		color = max(mix(pow(color, 1.0 - color), color / (2.0 * color + 0.5 - color), clamp(LIGHT_POSITION.y* 2.0, 0.0, 1.0)),0.0) + sun + gradient;

            if(isclipped == 1.0 && dot(eyespacePos,clipplane) > 0.0  )
            { 
                discard; 
            } 
        
            if(wPos.y < -0.01)
               		gl_FragColor = vec4(0.11,0.18,0.23, 1.0);       
           	else
                	gl_FragColor = vec4(color, 1.0);
            
            	
	}
    </script>

<script id="vertexShader" type="x-shader/x-vertex">
        precision mediump float; 
        precision highp sampler2D;

        uniform mat4 projMatrix; 
        uniform mat4 viewMatrix;
        uniform mat4 birdviewMatrix;

        uniform vec3 cameraPosition; 

        uniform mat4 invProjMatrix;
        uniform mat4 invViewMatrix;
          
        uniform sampler2D displacement; 

        attribute vec3 position; 
        attribute vec2 texCoord; 
        
        varying vec2 texcoord; 
        varying vec4 clipSpace;
        
        
        
        varying vec4 wPosition; 
        varying vec4 pos; 
        varying vec3 camPos;
        
        void main(void)
        { 
            vec4 vertex = vec4(position.x, position.z, 0.0, 1.0); 
    
            vec3 cameraSpace = normalize((invProjMatrix * vertex).xyz);
            vec3 worldSpace  = (invViewMatrix * vec4(cameraSpace, 0.0)).xyz;

            float t = (-cameraPosition.y)/worldSpace.y ;

            vec3 u =  (cameraPosition + t * worldSpace);

            texcoord = (u.xz + 1.0) * 0.5; 
    
            vec4 d  = texture2D(displacement, texcoord);
            
            camPos = cameraPosition;
              
            //attenuation horizont
            float att = 1.4/pow(length(camPos - u), 1.0/3.0);
            
            u.y = d.y * att;
            u.x = (u.x + d.x);
            u.z = (u.z + d.z);
    		

	        wPosition = vec4(u.x, u.y, u.z, 1.0);
            clipSpace  = projMatrix * viewMatrix * vec4(u , 1.0); 

            pos = (viewMatrix * vec4(worldSpace , 1.0)); 
            
            if (t > 0.0) 
            {
                gl_Position = clipSpace;
            }
            else
            {
                gl_Position = vec4(0.0,0.0,0.0,0.0);
             }
            
                
         }
    </script>
<script id="fragmentShader" type="x-shader/x-fragment">

        precision highp float;
        precision highp sampler2D;

        varying vec2 texcoord; 

        uniform sampler2D displacement; 
        uniform sampler2D reflectionSampler;
        uniform sampler2D refractionSampler; 
        
        varying vec3 camPos;
        varying vec4 wPosition;
        varying vec4 normalWorld; 
        varying vec4 pos; 
        
        varying vec4 eyespacePos;
        varying vec4 clipSpace; 

        vec3 calcNormals(sampler2D text, vec2 texcoords) { 

            float texel = 1.0 / 128.0;
            float texelSize = 1.0 / 64.0; 

            vec3 center = texture2D(text, texcoords).xyz; 

            vec3 left   = vec3(-texelSize, 0.0,0.0)  + texture2D(text, texcoords + vec2(-texel, 0.0)).xyz - center; 
            vec3 right  = vec3(texelSize, 0.0, 0.0)  + texture2D(text, texcoords + vec2(texel, 0.0)).xyz - center; 
            vec3 bottom = vec3(0.0, 0.0, texelSize)  + texture2D(text, texcoords + vec2(0.0, texel)).xyz - center;
            vec3 top    = vec3(0.0, 0.0, -texelSize) + texture2D(text, texcoords + vec2(0.0, -texel)).xyz - center; 

            vec3 topRight    = cross(right, top); 
            vec3 topLeft     = cross(top, left); 
            vec3 bottomLeft  = cross(left, bottom); 
            vec3 bottomRight = cross(bottom, right); 
    
            return normalize(topRight + topLeft + bottomLeft + bottomRight); 
        } 

        
        
        void main(void) { 
            vec3 LIGHTCOLOR         = vec3(0.5, 0.5, 0.5); 
            vec3 SEA_WATER_COLOR    = vec3(0.1,0.19,0.22); 
            vec3 DEEP_SEA_COLOR     = vec3(0.84,0.9,0.62);
            vec4 LIGHT_POSITION     = vec4(1000.0,3.0,-1900.0, 1.0); 

            vec3 lightDir = normalize(LIGHT_POSITION.xyz); 
            vec3 view     = normalize(camPos - wPosition.xyz); 
                
            
            vec2 reflectionCoord;
            vec2 refractionCoord; 
    
            reflectionCoord.x = 0.5*(clipSpace.w + clipSpace.x)/clipSpace.w;
            reflectionCoord.y = 0.5*(clipSpace.w - clipSpace.y)/clipSpace.w;
    
            refractionCoord.x = 0.5*(clipSpace.w + clipSpace.x)/clipSpace.w;
            refractionCoord.y = 0.5*(clipSpace.w + clipSpace.y)/clipSpace.w;
    
            vec3 normal    = calcNormals(displacement, texcoord);
            

            if (dot(view, normal) < 0.0) {
                normal = reflect(normal, view);
            }     
            
            vec4 refractionTex = texture2D(refractionSampler, refractionCoord + 0.1*normal.xz); 
            vec4 reflectionTex = texture2D(reflectionSampler, reflectionCoord - 0.1*normal.xz); 
        
            float diffuseFactor = clamp(dot(normal, lightDir.xyz), 0.0, 1.0); 
            
            float fresnel = 0.02 + 0.98 * pow(1.0 - dot(normal, view), 5.0);

            vec3 refraction = SEA_WATER_COLOR + diffuseFactor * (refractionTex.xyz + DEEP_SEA_COLOR*0.1); 
            vec3 reflection = reflectionTex.xyz;
		

            vec3 color = (refraction)*(1.0 -fresnel)+ (fresnel) *(SEA_WATER_COLOR*2.0 + reflectionTex.xyz) + LIGHTCOLOR*0.25 ;
            color += DEEP_SEA_COLOR * (wPosition.y*4.0/(length(camPos.xyz - wPosition.xyz)));
		
            float specular = pow(max(0.0, dot(reflect(lightDir, normal),-view)),600.0) * 10.0; 
            
            if(diffuseFactor>0.0)
                color+= specular * LIGHTCOLOR;
     
            gl_FragColor = vec4(1.0 - exp(-0.95*color), 1.0); 
    }
     </script>
</head>

<body>
    <div id="panel">
        <img id="spectrum"      width="128" height="128"/>
        <img id="hu"            width="128" height="128"/>
        <img id="spacial"       width="128" height="128"/>
        <input type = "text"    width="20" id="camera-height"/>
        <label id="cheight-lbl">camera height</label>
        <label id="choppiness-lbl">choppiness</label>
        <input id="choppiness" type="range" min="0" max="10" value="9" />
    </div>
    <canvas id="canvas"></canvas>
</body></html>
